# åŠ¨æ€æŠ€èƒ½åˆ›å»ºç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ

> **ç›®æ ‡**: è®© AI èƒ½å¤Ÿæ ¹æ®ç”¨æˆ·éœ€æ±‚è‡ªåŠ¨åˆ›å»ºæ–°çš„ Skillï¼Œå®ç°çœŸæ­£çš„è‡ªä¸»æ‰©å±•èƒ½åŠ›

---

## 1. æ–¹æ¡ˆæ¦‚è¿°

### 1.1 æ ¸å¿ƒæ€è·¯

```
ç”¨æˆ·éœ€æ±‚ â†’ AI åˆ†æ â†’ æ£€æŸ¥ç°æœ‰æŠ€èƒ½ â†’ æŠ€èƒ½ä¸å­˜åœ¨ â†’ è‡ªåŠ¨åˆ›å»ºæŠ€èƒ½ â†’ æ‰§è¡Œä»»åŠ¡
```

### 1.2 å·¥ä½œæµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant AI as AI Agent
    participant SkillMgr as Skill Manager
    participant Creator as Skill Creator
    participant Executor as Skill Executor

    User->>AI: "å¸®æˆ‘åˆ†æè¿™ä¸ª CSV æ–‡ä»¶çš„æ•°æ®åˆ†å¸ƒ"
    AI->>SkillMgr: æŸ¥æ‰¾ç›¸å…³æŠ€èƒ½
    SkillMgr-->>AI: æœªæ‰¾åˆ° csv_analysis æŠ€èƒ½

    AI->>Creator: åˆ›å»º csv_analysis æŠ€èƒ½
    Creator->>Creator: ç”Ÿæˆ SKILL.md
    Creator->>Creator: ç”Ÿæˆ Python è„šæœ¬
    Creator->>Creator: æµ‹è¯•æŠ€èƒ½
    Creator-->>AI: æŠ€èƒ½åˆ›å»ºæˆåŠŸ

    AI->>Executor: æ‰§è¡Œæ–°æŠ€èƒ½
    Executor-->>AI: è¿”å›åˆ†æç»“æœ
    AI-->>User: "è¿™æ˜¯æ•°æ®åˆ†æç»“æœ..."
```

---

## 2. å®ç°æ–¹æ¡ˆ

### æ–¹æ¡ˆ A: åŸºäºç°æœ‰ skill-creatorï¼ˆæ¨èï¼‰

AionUi å·²ç»å†…ç½®äº† `skill-creator` æŠ€èƒ½ï¼æˆ‘ä»¬åªéœ€è¦å¢å¼ºå®ƒã€‚

#### 2.1 æŸ¥çœ‹ç°æœ‰å®ç°

```bash
# æŸ¥çœ‹ç°æœ‰çš„ skill-creator
ls -la skills/skill-creator/
```

ç°æœ‰ç»“æ„ï¼š

```
skills/skill-creator/
â”œâ”€â”€ SKILL.md           # æŠ€èƒ½å®šä¹‰
â”œâ”€â”€ create_skill.py    # åˆ›å»ºæŠ€èƒ½çš„è„šæœ¬
â””â”€â”€ templates/         # æŠ€èƒ½æ¨¡æ¿ï¼ˆå¦‚æœæœ‰ï¼‰
```

#### 2.2 å¢å¼ºæ–¹æ¡ˆ

æˆ‘ä»¬éœ€è¦è®© AI èƒ½å¤Ÿï¼š

1. **è‡ªåŠ¨æ£€æµ‹**æŠ€èƒ½æ˜¯å¦å­˜åœ¨
2. **è‡ªåŠ¨å†³å®š**æ˜¯å¦éœ€è¦åˆ›å»ºæ–°æŠ€èƒ½
3. **è‡ªåŠ¨åˆ›å»º**å¹¶æµ‹è¯•æŠ€èƒ½
4. **è‡ªåŠ¨åŠ è½½**æ–°æŠ€èƒ½åˆ°å½“å‰ä¼šè¯

---

## 3. è¯¦ç»†å®ç°æ­¥éª¤

### æ­¥éª¤ 1: å¢å¼º Skill Creator

#### åˆ›å»ºå¢å¼ºç‰ˆçš„æŠ€èƒ½åˆ›å»ºè„šæœ¬

````python
# skills/skill-creator/auto_create_skill.py
"""
è‡ªåŠ¨æŠ€èƒ½åˆ›å»ºå™¨ - æ ¹æ®éœ€æ±‚æè¿°è‡ªåŠ¨ç”ŸæˆæŠ€èƒ½
"""
import os
import sys
import json
from pathlib import Path

def analyze_requirement(requirement: str) -> dict:
    """
    åˆ†æç”¨æˆ·éœ€æ±‚ï¼Œæå–æŠ€èƒ½ä¿¡æ¯

    Args:
        requirement: ç”¨æˆ·éœ€æ±‚æè¿°

    Returns:
        {
            "skill_name": "csv_analyzer",
            "description": "Analyze CSV file data distribution",
            "language": "python",
            "dependencies": ["pandas", "matplotlib"],
            "input_params": ["file_path"],
            "output_format": "json"
        }
    """
    # è¿™é‡Œå¯ä»¥ç”¨ç®€å•çš„è§„åˆ™æˆ–è€…è°ƒç”¨ LLM æ¥åˆ†æ
    # ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬ä½¿ç”¨ç®€å•çš„å…³é”®è¯åŒ¹é…

    skill_info = {
        "skill_name": "",
        "description": requirement,
        "language": "python",
        "dependencies": [],
        "input_params": [],
        "output_format": "json"
    }

    # æ ¹æ®å…³é”®è¯æ¨æ–­æŠ€èƒ½ç±»å‹
    if "csv" in requirement.lower() or "excel" in requirement.lower():
        skill_info["skill_name"] = "csv_analyzer"
        skill_info["dependencies"] = ["pandas"]
        skill_info["input_params"] = ["file_path"]
    elif "image" in requirement.lower() or "picture" in requirement.lower():
        skill_info["skill_name"] = "image_processor"
        skill_info["dependencies"] = ["pillow"]
        skill_info["input_params"] = ["image_path"]
    elif "api" in requirement.lower() or "http" in requirement.lower():
        skill_info["skill_name"] = "api_caller"
        skill_info["dependencies"] = ["requests"]
        skill_info["input_params"] = ["url", "method"]
    else:
        # é€šç”¨æŠ€èƒ½
        skill_info["skill_name"] = "custom_task"
        skill_info["input_params"] = ["input_data"]

    return skill_info


def generate_skill_md(skill_info: dict) -> str:
    """ç”Ÿæˆ SKILL.md å†…å®¹"""

    params_doc = "\n".join([
        f"- `{param}`: Description of {param}"
        for param in skill_info["input_params"]
    ])

    deps_doc = ", ".join(skill_info["dependencies"]) if skill_info["dependencies"] else "None"

    return f"""---
name: {skill_info["skill_name"]}
description: {skill_info["description"]}
auto_generated: true
created_at: {import_datetime()}
---

# {skill_info["skill_name"].replace('_', ' ').title()}

{skill_info["description"]}

## Tools

### {skill_info["skill_name"]}.py

**Location:** `skills/{skill_info["skill_name"]}/{skill_info["skill_name"]}.py`

**Dependencies:** {deps_doc}

**Usage:**
```bash
python skills/{skill_info["skill_name"]}/{skill_info["skill_name"]}.py <args>
````

**Arguments:**
{params_doc}

**Output:**
Returns {skill_info["output_format"].upper()} with the following structure:

```json
{{
  "status": "success",
  "result": "..."
}}
```

**Example:**

```bash
python skills/{skill_info["skill_name"]}/{skill_info["skill_name"]}.py "input"
```

## Notes

This skill was automatically generated. You may need to customize it for your specific use case.
"""

def generate_python_script(skill_info: dict, requirement: str) -> str:
"""ç”Ÿæˆ Python è„šæœ¬å†…å®¹"""

    # æ ¹æ®æŠ€èƒ½ç±»å‹ç”Ÿæˆä¸åŒçš„æ¨¡æ¿
    if "csv" in skill_info["skill_name"]:
        return generate_csv_analyzer_script()
    elif "image" in skill_info["skill_name"]:
        return generate_image_processor_script()
    elif "api" in skill_info["skill_name"]:
        return generate_api_caller_script()
    else:
        return generate_generic_script(skill_info, requirement)

def generate_csv_analyzer_script() -> str:
"""ç”Ÿæˆ CSV åˆ†æè„šæœ¬"""
return '''#!/usr/bin/env python3
"""
CSV Analyzer - Analyze CSV file data distribution
Auto-generated skill
"""
import sys
import json
import pandas as pd

def analyze_csv(file_path: str) -> dict:
"""Analyze CSV file and return statistics"""
try: # Read CSV
df = pd.read_csv(file_path)

        # Basic statistics
        result = {
            "status": "success",
            "rows": len(df),
            "columns": len(df.columns),
            "column_names": df.columns.tolist(),
            "data_types": df.dtypes.astype(str).to_dict(),
            "missing_values": df.isnull().sum().to_dict(),
            "numeric_summary": df.describe().to_dict() if len(df.select_dtypes(include=['number']).columns) > 0 else {},
        }

        return result
    except Exception as e:
        return {
            "status": "error",
            "error": str(e)
        }

def main():
if len(sys.argv) < 2:
print(json.dumps({"status": "error", "error": "Missing file_path argument"}))
sys.exit(1)

    file_path = sys.argv[1]
    result = analyze_csv(file_path)
    print(json.dumps(result, indent=2))

if **name** == "**main**":
main()
'''

def generate_generic_script(skill_info: dict, requirement: str) -> str:
"""ç”Ÿæˆé€šç”¨è„šæœ¬æ¨¡æ¿"""
return f'''#!/usr/bin/env python3
"""
{skill_info["skill_name"]} - {skill_info["description"]}
Auto-generated skill
"""
import sys
import json

def execute_task(input_data: str) -> dict:
"""
Execute the task based on requirement:
{requirement}

    TODO: Implement the actual logic here
    """
    try:
        # TODO: Add your implementation here
        result = {{
            "status": "success",
            "message": "Task completed",
            "input": input_data,
            "output": "TODO: Implement actual logic"
        }}

        return result
    except Exception as e:
        return {{
            "status": "error",
            "error": str(e)
        }}

def main():
if len(sys.argv) < 2:
print(json.dumps({{"status": "error", "error": "Missing input argument"}}))
sys.exit(1)

    input_data = sys.argv[1]
    result = execute_task(input_data)
    print(json.dumps(result, indent=2))

if **name** == "**main**":
main()
'''

def create_skill(requirement: str, skills_dir: str = None) -> dict:
"""
è‡ªåŠ¨åˆ›å»ºæŠ€èƒ½

    Args:
        requirement: ç”¨æˆ·éœ€æ±‚æè¿°
        skills_dir: æŠ€èƒ½ç›®å½•è·¯å¾„

    Returns:
        åˆ›å»ºç»“æœ
    """
    # ç¡®å®šæŠ€èƒ½ç›®å½•
    if skills_dir is None:
        skills_dir = Path(__file__).parent.parent
    else:
        skills_dir = Path(skills_dir)

    # åˆ†æéœ€æ±‚
    skill_info = analyze_requirement(requirement)
    skill_name = skill_info["skill_name"]

    # åˆ›å»ºæŠ€èƒ½ç›®å½•
    skill_dir = skills_dir / skill_name
    if skill_dir.exists():
        return {
            "status": "error",
            "error": f"Skill '{skill_name}' already exists"
        }

    skill_dir.mkdir(parents=True, exist_ok=True)

    # ç”Ÿæˆ SKILL.md
    skill_md_content = generate_skill_md(skill_info)
    (skill_dir / "SKILL.md").write_text(skill_md_content)

    # ç”Ÿæˆ Python è„šæœ¬
    script_content = generate_python_script(skill_info, requirement)
    script_path = skill_dir / f"{skill_name}.py"
    script_path.write_text(script_content)
    script_path.chmod(0o755)  # æ·»åŠ æ‰§è¡Œæƒé™

    # å®‰è£…ä¾èµ–ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if skill_info["dependencies"]:
        try:
            import subprocess
            subprocess.run(
                ["pip", "install"] + skill_info["dependencies"],
                check=True,
                capture_output=True
            )
        except Exception as e:
            return {
                "status": "warning",
                "message": f"Skill created but dependencies installation failed: {e}",
                "skill_name": skill_name,
                "skill_path": str(skill_dir)
            }

    return {
        "status": "success",
        "message": f"Skill '{skill_name}' created successfully",
        "skill_name": skill_name,
        "skill_path": str(skill_dir),
        "script_path": str(script_path),
        "usage": f"python {script_path} <args>"
    }

def import_datetime():
"""å¯¼å…¥ datetime å¹¶è¿”å›å½“å‰æ—¶é—´"""
from datetime import datetime
return datetime.now().isoformat()

def main():
if len(sys.argv) < 2:
print(json.dumps({
"status": "error",
"error": "Usage: python auto_create_skill.py '<requirement description>' [skills_dir]"
}))
sys.exit(1)

    requirement = sys.argv[1]
    skills_dir = sys.argv[2] if len(sys.argv) > 2 else None

    result = create_skill(requirement, skills_dir)
    print(json.dumps(result, indent=2))

if **name** == "**main**":
main()

````

#### æ›´æ–° SKILL.md

```markdown
<!-- skills/skill-creator/SKILL.md -->
---
name: skill-creator
description: Automatically create new skills based on user requirements
---

# Skill Creator

This skill allows the AI to automatically create new skills when needed.

## Tools

### auto_create_skill.py

**Location:** `skills/skill-creator/auto_create_skill.py`

**Usage:**
```bash
python skills/skill-creator/auto_create_skill.py "<requirement description>" [skills_dir]
````

**Arguments:**

- `requirement`: Description of what the skill should do
- `skills_dir`: (Optional) Path to skills directory

**Output:**
Returns JSON with:

```json
{
  "status": "success",
  "skill_name": "csv_analyzer",
  "skill_path": "/path/to/skills/csv_analyzer",
  "script_path": "/path/to/skills/csv_analyzer/csv_analyzer.py",
  "usage": "python /path/to/skills/csv_analyzer/csv_analyzer.py <args>"
}
```

**Example:**

```bash
python skills/skill-creator/auto_create_skill.py "Analyze CSV file data distribution"
```

## Workflow

1. AI detects that a required skill doesn't exist
2. AI calls `auto_create_skill.py` with the requirement description
3. Script analyzes the requirement and generates:
   - SKILL.md (skill definition)
   - Python script (implementation)
4. AI can immediately use the new skill
5. User can customize the generated skill if needed

## Supported Skill Types

- **CSV/Excel Analysis**: Automatically generates pandas-based analyzers
- **Image Processing**: Generates PIL/Pillow-based processors
- **API Calling**: Generates requests-based API clients
- **Generic Tasks**: Generates customizable templates

## Notes

- Generated skills may need customization for complex requirements
- AI should inform the user when a new skill is created
- Users can manually edit generated skills in the `skills/` directory

````

---

### æ­¥éª¤ 2: å¢å¼º AI Agent çš„æŠ€èƒ½æ£€æµ‹é€»è¾‘

#### ä¿®æ”¹ GeminiAgent æ·»åŠ è‡ªåŠ¨æŠ€èƒ½åˆ›å»º

```typescript
// src/agent/gemini/index.ts
export class GeminiAgent {
  private enabledSkills: string[];
  private skillsDir: string;
  private autoCreateSkills: boolean = true; // æ–°å¢ï¼šæ˜¯å¦è‡ªåŠ¨åˆ›å»ºæŠ€èƒ½

  async send(message: string): Promise<void> {
    // åœ¨å‘é€æ¶ˆæ¯å‰ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºæ–°æŠ€èƒ½
    if (this.autoCreateSkills) {
      await this.checkAndCreateSkills(message);
    }

    // åŸæœ‰çš„å‘é€é€»è¾‘
    // ...
  }

  private async checkAndCreateSkills(message: string): Promise<void> {
    // 1. åˆ†ææ¶ˆæ¯ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦æ–°æŠ€èƒ½
    const needsNewSkill = await this.analyzeSkillRequirement(message);

    if (needsNewSkill) {
      // 2. è°ƒç”¨ skill-creator åˆ›å»ºæŠ€èƒ½
      const result = await this.createSkill(needsNewSkill.requirement);

      if (result.status === 'success') {
        // 3. åŠ¨æ€åŠ è½½æ–°æŠ€èƒ½
        await this.loadNewSkill(result.skill_name);

        // 4. é€šçŸ¥ç”¨æˆ·
        this.emit('skill-created', {
          skill_name: result.skill_name,
          message: `Created new skill: ${result.skill_name}`,
        });
      }
    }
  }

  private async analyzeSkillRequirement(message: string): Promise<{ requirement: string } | null> {
    // ç®€å•çš„å…³é”®è¯æ£€æµ‹
    // å®é™…åº”ç”¨ä¸­å¯ä»¥ç”¨ LLM æ¥åˆ†æ

    const keywords = {
      csv: /analyze.*csv|csv.*analysis|parse.*csv/i,
      image: /process.*image|edit.*picture|convert.*image/i,
      api: /call.*api|fetch.*data|http.*request/i,
    };

    for (const [type, pattern] of Object.entries(keywords)) {
      if (pattern.test(message)) {
        // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸å…³æŠ€èƒ½
        const hasSkill = this.enabledSkills.some(skill =>
          skill.includes(type) || skill.includes('analyzer')
        );

        if (!hasSkill) {
          return { requirement: message };
        }
      }
    }

    return null;
  }

  private async createSkill(requirement: string): Promise<any> {
    // è°ƒç”¨ skill-creator
    const { spawn } = require('child_process');

    return new Promise((resolve, reject) => {
      const process = spawn('python', [
        `${this.skillsDir}/skill-creator/auto_create_skill.py`,
        requirement,
        this.skillsDir,
      ]);

      let output = '';
      process.stdout.on('data', (data: Buffer) => {
        output += data.toString();
      });

      process.on('close', (code: number) => {
        if (code === 0) {
          try {
            const result = JSON.parse(output);
            resolve(result);
          } catch (e) {
            reject(new Error('Failed to parse skill creation result'));
          }
        } else {
          reject(new Error('Skill creation failed'));
        }
      });
    });
  }

  private async loadNewSkill(skillName: string): Promise<void> {
    // åŠ¨æ€åŠ è½½æ–°æŠ€èƒ½åˆ°å½“å‰ä¼šè¯
    const skillPath = `${this.skillsDir}/${skillName}/SKILL.md`;
    const skillContent = await fs.readFile(skillPath, 'utf-8');

    // æ·»åŠ åˆ°å¯ç”¨çš„æŠ€èƒ½åˆ—è¡¨
    this.enabledSkills.push(skillName);

    // é‡æ–°åŠ è½½æŠ€èƒ½å†…å®¹åˆ° System Prompt
    await this.reloadSkills();
  }

  private async reloadSkills(): Promise<void> {
    // é‡æ–°åŠ è½½æ‰€æœ‰å¯ç”¨çš„æŠ€èƒ½
    const { loadSkillsContent } = require('@/process/initStorage');
    const skillsContent = await loadSkillsContent(this.enabledSkills);

    // æ›´æ–° System Prompt
    this.systemPrompt = this.buildSystemPrompt(skillsContent);
  }
}
````

---

### æ­¥éª¤ 3: æ·»åŠ ç”¨æˆ·ç•Œé¢æç¤º

#### åœ¨å‰ç«¯æ˜¾ç¤ºæŠ€èƒ½åˆ›å»ºé€šçŸ¥

```typescript
// src/renderer/components/SkillCreationNotification.tsx
import { Message } from '@arco-design/web-react';
import { useEffect } from 'react';
import { ipcBridge } from '@/common/ipcBridge';

export const SkillCreationNotification = () => {
  useEffect(() => {
    // ç›‘å¬æŠ€èƒ½åˆ›å»ºäº‹ä»¶
    const unsubscribe = ipcBridge.geminiConversation.responseStream.subscribe((msg) => {
      if (msg.type === 'skill-created') {
        Message.success({
          content: `ğŸ‰ New skill created: ${msg.data.skill_name}`,
          duration: 5000,
        });
      }
    });

    return unsubscribe;
  }, []);

  return null;
};
```

---

### æ­¥éª¤ 4: æ·»åŠ é…ç½®é€‰é¡¹

#### åœ¨è®¾ç½®ä¸­æ·»åŠ å¼€å…³

```typescript
// src/renderer/pages/settings/SkillSettings.tsx
import { Switch, Typography } from '@arco-design/web-react';

export const SkillSettings = () => {
  const [autoCreate, setAutoCreate] = useState(true);

  const handleToggle = async (checked: boolean) => {
    setAutoCreate(checked);
    await ipcBridge.config.set('skills.autoCreate', checked);
  };

  return (
    <div>
      <Typography.Title heading={6}>Skill Settings</Typography.Title>

      <div className="setting-item">
        <div>
          <Typography.Text>Auto-create Skills</Typography.Text>
          <Typography.Text type="secondary" style={{ display: 'block', fontSize: '12px' }}>
            Automatically create new skills when needed
          </Typography.Text>
        </div>
        <Switch checked={autoCreate} onChange={handleToggle} />
      </div>
    </div>
  );
};
```

---

## 4. ä½¿ç”¨ç¤ºä¾‹

### åœºæ™¯ 1: CSV åˆ†æ

```
ç”¨æˆ·: å¸®æˆ‘åˆ†æè¿™ä¸ª sales_data.csv æ–‡ä»¶çš„æ•°æ®åˆ†å¸ƒ

AI æ€è€ƒè¿‡ç¨‹:
1. æ£€æµ‹åˆ°éœ€è¦ CSV åˆ†æåŠŸèƒ½
2. æ£€æŸ¥ç°æœ‰æŠ€èƒ½ â†’ æœªæ‰¾åˆ° csv_analyzer
3. è°ƒç”¨ skill-creator åˆ›å»ºæŠ€èƒ½
4. ç”Ÿæˆ skills/csv_analyzer/SKILL.md
5. ç”Ÿæˆ skills/csv_analyzer/csv_analyzer.py
6. åŠ è½½æ–°æŠ€èƒ½åˆ°å½“å‰ä¼šè¯
7. æ‰§è¡Œ: python skills/csv_analyzer/csv_analyzer.py "sales_data.csv"
8. è¿”å›åˆ†æç»“æœ

AI å›å¤:
"æˆ‘åˆšåˆšåˆ›å»ºäº†ä¸€ä¸ª CSV åˆ†ææŠ€èƒ½æ¥å¸®ä½ å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚

åˆ†æç»“æœ:
- æ€»è¡Œæ•°: 1000
- åˆ—æ•°: 5
- åˆ—å: date, product, quantity, price, total
- ç¼ºå¤±å€¼: æ— 
- æ•°å€¼ç»Ÿè®¡: ..."
```

### åœºæ™¯ 2: å›¾åƒå¤„ç†

```
ç”¨æˆ·: æŠŠè¿™å¼ å›¾ç‰‡è½¬æ¢æˆç°åº¦å›¾

AI æ€è€ƒè¿‡ç¨‹:
1. æ£€æµ‹åˆ°éœ€è¦å›¾åƒå¤„ç†åŠŸèƒ½
2. æ£€æŸ¥ç°æœ‰æŠ€èƒ½ â†’ æœªæ‰¾åˆ° image_processor
3. è‡ªåŠ¨åˆ›å»º image_processor æŠ€èƒ½
4. æ‰§è¡Œå›¾åƒè½¬æ¢
5. è¿”å›ç»“æœ

AI å›å¤:
"æˆ‘åˆ›å»ºäº†ä¸€ä¸ªå›¾åƒå¤„ç†æŠ€èƒ½ï¼Œå·²ç»å°†å›¾ç‰‡è½¬æ¢ä¸ºç°åº¦å›¾ã€‚
ä¿å­˜ä½ç½®: output_grayscale.png"
```

---

## 5. é«˜çº§åŠŸèƒ½

### 5.1 æŠ€èƒ½å­¦ä¹ å’Œä¼˜åŒ–

```python
# skills/skill-creator/optimize_skill.py
"""
æŠ€èƒ½ä¼˜åŒ–å™¨ - æ ¹æ®ä½¿ç”¨åé¦ˆä¼˜åŒ–æŠ€èƒ½
"""

def optimize_skill(skill_name: str, feedback: dict) -> dict:
    """
    æ ¹æ®ç”¨æˆ·åé¦ˆä¼˜åŒ–æŠ€èƒ½

    Args:
        skill_name: æŠ€èƒ½åç§°
        feedback: {
            "success": bool,
            "error": str,
            "suggestions": str
        }
    """
    # è¯»å–ç°æœ‰æŠ€èƒ½
    skill_path = f"skills/{skill_name}/{skill_name}.py"

    # åˆ†æåé¦ˆ
    if not feedback["success"]:
        # ä¿®å¤é”™è¯¯
        # å¯ä»¥è°ƒç”¨ LLM æ¥ç”Ÿæˆä¿®å¤ä»£ç 
        pass

    # åº”ç”¨ä¼˜åŒ–
    # ...

    return {
        "status": "success",
        "message": "Skill optimized"
    }
```

### 5.2 æŠ€èƒ½ç‰ˆæœ¬ç®¡ç†

```python
# skills/skill-creator/version_manager.py
"""
æŠ€èƒ½ç‰ˆæœ¬ç®¡ç†
"""

def create_skill_version(skill_name: str) -> str:
    """åˆ›å»ºæŠ€èƒ½ç‰ˆæœ¬å¿«ç…§"""
    import shutil
    from datetime import datetime

    version = datetime.now().strftime("%Y%m%d_%H%M%S")
    src = f"skills/{skill_name}"
    dst = f"skills/{skill_name}/.versions/{version}"

    shutil.copytree(src, dst)
    return version

def rollback_skill(skill_name: str, version: str) -> bool:
    """å›æ»šåˆ°æŒ‡å®šç‰ˆæœ¬"""
    import shutil

    src = f"skills/{skill_name}/.versions/{version}"
    dst = f"skills/{skill_name}"

    shutil.rmtree(dst)
    shutil.copytree(src, dst)
    return True
```

### 5.3 æŠ€èƒ½å¸‚åœº

```typescript
// æœªæ¥å¯ä»¥å®ç°æŠ€èƒ½åˆ†äº«å’Œä¸‹è½½
interface SkillMarketplace {
  search(query: string): Skill[];
  download(skillId: string): Promise<void>;
  publish(skill: Skill): Promise<void>;
  rate(skillId: string, rating: number): Promise<void>;
}
```

---

## 6. å®‰å…¨è€ƒè™‘

### 6.1 ä»£ç å®¡æŸ¥

```python
# skills/skill-creator/security_checker.py
"""
å®‰å…¨æ£€æŸ¥å™¨ - æ£€æŸ¥ç”Ÿæˆçš„ä»£ç æ˜¯å¦å®‰å…¨
"""

DANGEROUS_PATTERNS = [
    r'os\.system',
    r'subprocess\.call',
    r'eval\(',
    r'exec\(',
    r'__import__',
    r'open\(.*[\'"]w[\'"]',  # å†™æ–‡ä»¶
]

def check_security(code: str) -> dict:
    """æ£€æŸ¥ä»£ç å®‰å…¨æ€§"""
    import re

    issues = []
    for pattern in DANGEROUS_PATTERNS:
        if re.search(pattern, code):
            issues.append(f"Potentially dangerous pattern: {pattern}")

    return {
        "safe": len(issues) == 0,
        "issues": issues
    }
```

### 6.2 æ²™ç®±æ‰§è¡Œ

```python
# åœ¨éš”ç¦»ç¯å¢ƒä¸­æ‰§è¡Œæ–°åˆ›å»ºçš„æŠ€èƒ½
import subprocess

def execute_in_sandbox(script_path: str, args: list) -> dict:
    """åœ¨æ²™ç®±ä¸­æ‰§è¡Œè„šæœ¬"""
    try:
        result = subprocess.run(
            ['python', script_path] + args,
            capture_output=True,
            timeout=30,  # 30ç§’è¶…æ—¶
            text=True
        )
        return {
            "status": "success",
            "output": result.stdout
        }
    except subprocess.TimeoutExpired:
        return {
            "status": "error",
            "error": "Execution timeout"
        }
```

---

## 7. é…ç½®å’Œéƒ¨ç½²

### 7.1 å¯ç”¨è‡ªåŠ¨æŠ€èƒ½åˆ›å»º

```typescript
// åœ¨ä¼šè¯åˆ›å»ºæ—¶å¯ç”¨
const conversation = await ipcBridge.conversation.create({
  type: 'gemini',
  model: selectedModel,
  extra: {
    workspace: '/path/to/workspace',
    enabledSkills: ['skill-creator'], // å¯ç”¨ skill-creator
    autoCreateSkills: true, // å¯ç”¨è‡ªåŠ¨åˆ›å»º
  },
});
```

### 7.2 ç¯å¢ƒå˜é‡é…ç½®

```bash
# .env
AIONUI_AUTO_CREATE_SKILLS=true
AIONUI_SKILLS_DIR=/path/to/skills
AIONUI_MAX_SKILL_CREATION_PER_SESSION=5
```

---

## 8. æµ‹è¯•

### 8.1 å•å…ƒæµ‹è¯•

```python
# tests/test_skill_creator.py
import unittest
from skills.skill_creator.auto_create_skill import create_skill

class TestSkillCreator(unittest.TestCase):
    def test_create_csv_analyzer(self):
        result = create_skill("Analyze CSV file data distribution")
        self.assertEqual(result["status"], "success")
        self.assertIn("csv", result["skill_name"])

    def test_create_image_processor(self):
        result = create_skill("Convert image to grayscale")
        self.assertEqual(result["status"], "success")
        self.assertIn("image", result["skill_name"])
```

### 8.2 é›†æˆæµ‹è¯•

```typescript
// tests/integration/skill-creation.test.ts
describe('Auto Skill Creation', () => {
  it('should create skill when needed', async () => {
    const agent = new GeminiAgent({
      autoCreateSkills: true,
      enabledSkills: ['skill-creator'],
    });

    await agent.send('Analyze this CSV file');

    // éªŒè¯æŠ€èƒ½å·²åˆ›å»º
    const skills = await listSkills();
    expect(skills).toContain('csv_analyzer');
  });
});
```

---

## 9. æ€»ç»“

### å®ç°è¦ç‚¹

1. âœ… **åˆ©ç”¨ç°æœ‰ skill-creator** - AionUi å·²æœ‰åŸºç¡€
2. âœ… **å¢å¼ºè‡ªåŠ¨æ£€æµ‹** - AI è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦éœ€è¦æ–°æŠ€èƒ½
3. âœ… **åŠ¨æ€åŠ è½½** - åˆ›å»ºåç«‹å³å¯ç”¨
4. âœ… **ç”¨æˆ·é€šçŸ¥** - å‘ŠçŸ¥ç”¨æˆ·æŠ€èƒ½åˆ›å»º
5. âœ… **å®‰å…¨æ£€æŸ¥** - é˜²æ­¢æ¶æ„ä»£ç 

### ä¼˜åŠ¿

- ğŸš€ **çœŸæ­£çš„è‡ªä¸»æ‰©å±•** - AI å¯ä»¥è‡ªå·±å­¦ä¹ æ–°èƒ½åŠ›
- ğŸ¯ **æŒ‰éœ€åˆ›å»º** - åªåœ¨éœ€è¦æ—¶åˆ›å»ºï¼Œä¸æµªè´¹èµ„æº
- ğŸ”„ **æŒç»­ä¼˜åŒ–** - å¯ä»¥æ ¹æ®åé¦ˆæ”¹è¿›æŠ€èƒ½
- ğŸ“¦ **å¯å¤ç”¨** - åˆ›å»ºçš„æŠ€èƒ½å¯ä»¥åœ¨æœªæ¥å¤ç”¨

### ä¸‹ä¸€æ­¥

1. å®ç°åŸºç¡€çš„ `auto_create_skill.py`
2. åœ¨ GeminiAgent ä¸­æ·»åŠ æ£€æµ‹é€»è¾‘
3. æµ‹è¯•å‡ ä¸ªå¸¸è§åœºæ™¯
4. æ·»åŠ ç”¨æˆ·ç•Œé¢æç¤º
5. å®Œå–„å®‰å…¨æ£€æŸ¥

éœ€è¦æˆ‘å¸®ä½ ç”Ÿæˆå®Œæ•´çš„ä»£ç æ–‡ä»¶å—ï¼Ÿ
